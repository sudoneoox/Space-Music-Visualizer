{"id":"node_modules/av/src/core/events.coffee","dependencies":[{"name":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\package.json","includedInParent":true,"mtime":1624288368876},{"name":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\node_modules\\av\\package.json","includedInParent":true,"mtime":1624288427802},{"name":"./base","loc":{"line":4,"column":17},"parent":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\node_modules\\av\\src\\core\\events.coffee","resolved":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\node_modules\\av\\src\\core\\base.coffee"}],"generated":{"js":"(function() {\n  var Base, EventEmitter;\n\n  Base = require('./base');\n\n  EventEmitter = class EventEmitter extends Base {\n    on(event, fn) {\n      var base;\n      if (this.events == null) {\n        this.events = {};\n      }\n      if ((base = this.events)[event] == null) {\n        base[event] = [];\n      }\n      return this.events[event].push(fn);\n    }\n\n    off(event, fn) {\n      var events, index, ref;\n      if (this.events == null) {\n        return;\n      }\n      if ((ref = this.events) != null ? ref[event] : void 0) {\n        if (fn != null) {\n          index = this.events[event].indexOf(fn);\n          if (~index) {\n            return this.events[event].splice(index, 1);\n          }\n        } else {\n          return this.events[event];\n        }\n      } else if (event == null) {\n        return events = {};\n      }\n    }\n\n    once(event, fn) {\n      var cb;\n      return this.on(event, cb = function() {\n        this.off(event, cb);\n        return fn.apply(this, arguments);\n      });\n    }\n\n    emit(event, ...args) {\n      var fn, i, len, ref, ref1;\n      if (!((ref = this.events) != null ? ref[event] : void 0)) {\n        return;\n      }\n      ref1 = this.events[event].slice();\n      \n      // shallow clone with .slice() so that removing a handler\n      // while event is firing (as in once) doesn't cause errors\n      for (i = 0, len = ref1.length; i < len; i++) {\n        fn = ref1[i];\n        fn.apply(this, args);\n      }\n    }\n\n  };\n\n  module.exports = EventEmitter;\n\n}).call(this);\n"},"sourceMaps":{"js":{"version":3,"file":"","sourceRoot":"","sources":["node_modules/av/src/core/events.coffee"],"names":[],"mappings":"AAAA;AAAA,MAAA,IAAA,EAAA;;EAAA,IAAA,GAAO,OAAA,CAAQ,QAAR;;EAED,eAAN,MAAA,aAAA,QAA2B,KAA3B;IACI,EAAI,CAAC,KAAD,EAAQ,EAAR,CAAA;AACR,UAAA;;QAAQ,IAAC,CAAA,SAAU,CAAA;;;YACJ,CAAC,KAAD,IAAW;;aAClB,IAAC,CAAA,MAAM,CAAC,KAAD,CAAO,CAAC,IAAf,CAAoB,EAApB;IAHA;;IAKJ,GAAK,CAAC,KAAD,EAAQ,EAAR,CAAA;AACT,UAAA,MAAA,EAAA,KAAA,EAAA;MAAQ,IAAc,mBAAd;AAAA,eAAA;;MACA,qCAAU,CAAE,KAAF,UAAV;QACI,IAAG,UAAH;UACI,KAAA,GAAQ,IAAC,CAAA,MAAM,CAAC,KAAD,CAAO,CAAC,OAAf,CAAuB,EAAvB;UACR,IAAmC,CAAC,KAApC;mBAAA,IAAC,CAAA,MAAM,CAAC,KAAD,CAAO,CAAC,MAAf,CAAsB,KAAtB,EAA6B,CAA7B,EAAA;WAFJ;SAAA,MAAA;iBAII,IAAC,CAAA,MAAM,CAAC,KAAD,EAJX;SADJ;OAAA,MAMK,IAAO,aAAP;eACD,MAAA,GAAS,CAAA,EADR;;IARJ;;IAWL,IAAM,CAAC,KAAD,EAAQ,EAAR,CAAA;AACV,UAAA;aAAQ,IAAC,CAAA,EAAD,CAAI,KAAJ,EAAW,EAAA,GAAK,QAAA,CAAA,CAAA;QACZ,IAAC,CAAA,GAAD,CAAK,KAAL,EAAY,EAAZ;eACA,EAAE,CAAC,KAAH,CAAS,IAAT,EAAe,SAAf;MAFY,CAAhB;IADE;;IAKN,IAAM,CAAC,KAAD,EAAA,GAAQ,IAAR,CAAA;AACV,UAAA,EAAA,EAAA,CAAA,EAAA,GAAA,EAAA,GAAA,EAAA;MAAQ,uCAAqB,CAAE,KAAF,WAArB;AAAA,eAAA;;AAIA;;;;MAAA,KAAA,sCAAA;;QACI,EAAE,CAAC,KAAH,CAAS,IAAT,EAAe,IAAf;MADJ;IALE;;EAtBV;;EAgCA,MAAM,CAAC,OAAP,GAAiB;AAlCjB","sourcesContent":["Base = require './base'\n\nclass EventEmitter extends Base\n    on: (event, fn) ->\n        @events ?= {}\n        @events[event] ?= []\n        @events[event].push(fn)\n        \n    off: (event, fn) ->\n        return unless @events?\n        if @events?[event]\n            if fn?\n                index = @events[event].indexOf(fn)\n                @events[event].splice(index, 1) if ~index\n            else\n                @events[event]\n        else unless event?\n            events = {}\n        \n    once: (event, fn) ->\n        @on event, cb = ->\n            @off event, cb\n            fn.apply(this, arguments)\n        \n    emit: (event, args...) ->\n        return unless @events?[event]\n        \n        # shallow clone with .slice() so that removing a handler\n        # while event is firing (as in once) doesn't cause errors\n        for fn in @events[event].slice()\n            fn.apply(this, args)\n            \n        return\n        \nmodule.exports = EventEmitter\n"]}},"error":null,"hash":"d6e136e8b04924e55ed047c25a75beed","cacheData":{"env":{}}}