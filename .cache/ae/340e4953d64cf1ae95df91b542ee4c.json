{"id":"src/assets/libs/shaders/song/songVertex.glsl","dependencies":[{"name":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\package.json","includedInParent":true,"mtime":1624327498692}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nvarying vec2 vUv;\\nvarying vec3 vNormal;\\nvarying float vNoise;\\nuniform int numOctaves;\\nuniform float time;\\nuniform float noiseStrength;\\nuniform float audioScale;\\nconst int aLargeNumber = 10;\\n\\nfloat generateNoise(int x, int y, int z, int numOctave) {\\n  if(numOctave == 0) {\\n    return fract(sin(dot(vec3(x, y, z), vec3(12.9898, 78.23, 107.81))) * 43758.5453);\\n  } else if(numOctave == 1) {\\n    return fract(sin(dot(vec3(z, x, y), vec3(16.363, 43.597, 199.73))) * 69484.7539);\\n  } else if(numOctave == 2) {\\n    return fract(sin(dot(vec3(y, x, z), vec3(13.0, 68.819, 90.989))) * 92041.9823);\\n  } else if(numOctave == 3) {\\n    return fract(sin(dot(vec3(x, y, z), vec3(98.1577, 47.45029, 154.85161))) * 84499.0);\\n  } else if(numOctave == 4) {\\n    return fract(sin(dot(vec3(z, x, y), vec3(9.75367, 83.3057, 390.353))) * 15485.653);\\n  }\\n}\\n\\nfloat linearInterpolate(float a, float b, float t) {\\n  return a * (1.0 - t) + b * t;\\n}\\n\\nfloat cosineInterpolate(float a, float b, float t) {\\n  float cos_t = (1.0 - cos(t * 3.14159265359879323846264)) * 0.5;\\n  return linearInterpolate(a, b, cos_t);\\n}\\n\\n// given a point in 3d space, produces a noise value by interpolating surrounding points\\nfloat interpolateNoise(float x, float y, float z, int numOctave) {\\n  int integerX = int(floor(x));\\n  float weightX = x - float(integerX);\\n\\n  int integerY = int(floor(y));\\n  float weightY = y - float(integerY);\\n\\n  int integerZ = int(floor(z));\\n  float weightZ = z - float(integerZ);\\n\\n  float v1 = generateNoise(integerX, integerY, integerZ, numOctave);\\n  float v2 = generateNoise(integerX, integerY, integerZ + 1, numOctave);\\n  float v3 = generateNoise(integerX, integerY + 1, integerZ + 1, numOctave);\\n  float v4 = generateNoise(integerX, integerY + 1, integerZ, numOctave);\\n\\n  float v5 = generateNoise(integerX + 1, integerY, integerZ, numOctave);\\n  float v6 = generateNoise(integerX + 1, integerY, integerZ + 1, numOctave);\\n  float v7 = generateNoise(integerX + 1, integerY + 1, integerZ + 1, numOctave);\\n  float v8 = generateNoise(integerX + 1, integerY + 1, integerZ, numOctave);\\n\\n  float i1 = cosineInterpolate(v1, v5, weightX);\\n  float i2 = cosineInterpolate(v2, v6, weightX);\\n  float i3 = cosineInterpolate(v3, v7, weightX);\\n  float i4 = cosineInterpolate(v4, v8, weightX);\\n\\n  float ii1 = cosineInterpolate(i1, i4, weightY);\\n  float ii2 = cosineInterpolate(i2, i3, weightY);\\n\\n  return cosineInterpolate(ii1, ii2, weightZ);\\n}\\n\\n// a multi-octave noise generation function that sums multiple noise functions together\\n// with each subsequent noise function increasing in frequency and decreasing in amplitude\\nfloat generateMultiOctaveNoise(float x, float y, float z) {\\n  float total = 0.0;\\n  float persistence = 1.0 / noiseStrength;\\n\\n    //loop for some number of octaves\\n  for(int i = 0; i < aLargeNumber; i++) {\\n    if(i == numOctaves)\\n      break;\\n    float frequency = pow(2.0, float(i));\\n    float amplitude = pow(persistence, float(i));\\n\\n    total += interpolateNoise(x * frequency, y * frequency, z * frequency, i) * amplitude;\\n  }\\n\\n  return total;\\n}\\n\\nvoid main() {\\n  float offset = generateMultiOctaveNoise(position[0] + time / 999.0, position[1] + time / 999.0, position[2] + time / 999.0);\\n  vec3 newPosition = position + offset * normal * audioScale;\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\\n  vUv = uv;\\n  vNormal = normal;\\n  vNoise = offset;\\n}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"src/assets/libs/shaders/song/songVertex.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"src/assets/libs/shaders/song/songVertex.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"src/assets/libs/shaders/song/songVertex.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"src/assets/libs/shaders/song/songVertex.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"src/assets/libs/shaders/song/songVertex.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":3496},"source":"src/assets/libs/shaders/song/songVertex.glsl","original":{"line":1,"column":0}}],"sources":{"src/assets/libs/shaders/song/songVertex.glsl":"module.exports=\"#define GLSLIFY 1\\nvarying vec2 vUv;\\nvarying vec3 vNormal;\\nvarying float vNoise;\\nuniform int numOctaves;\\nuniform float time;\\nuniform float noiseStrength;\\nuniform float audioScale;\\nconst int aLargeNumber = 10;\\n\\nfloat generateNoise(int x, int y, int z, int numOctave) {\\n  if(numOctave == 0) {\\n    return fract(sin(dot(vec3(x, y, z), vec3(12.9898, 78.23, 107.81))) * 43758.5453);\\n  } else if(numOctave == 1) {\\n    return fract(sin(dot(vec3(z, x, y), vec3(16.363, 43.597, 199.73))) * 69484.7539);\\n  } else if(numOctave == 2) {\\n    return fract(sin(dot(vec3(y, x, z), vec3(13.0, 68.819, 90.989))) * 92041.9823);\\n  } else if(numOctave == 3) {\\n    return fract(sin(dot(vec3(x, y, z), vec3(98.1577, 47.45029, 154.85161))) * 84499.0);\\n  } else if(numOctave == 4) {\\n    return fract(sin(dot(vec3(z, x, y), vec3(9.75367, 83.3057, 390.353))) * 15485.653);\\n  }\\n}\\n\\nfloat linearInterpolate(float a, float b, float t) {\\n  return a * (1.0 - t) + b * t;\\n}\\n\\nfloat cosineInterpolate(float a, float b, float t) {\\n  float cos_t = (1.0 - cos(t * 3.14159265359879323846264)) * 0.5;\\n  return linearInterpolate(a, b, cos_t);\\n}\\n\\n// given a point in 3d space, produces a noise value by interpolating surrounding points\\nfloat interpolateNoise(float x, float y, float z, int numOctave) {\\n  int integerX = int(floor(x));\\n  float weightX = x - float(integerX);\\n\\n  int integerY = int(floor(y));\\n  float weightY = y - float(integerY);\\n\\n  int integerZ = int(floor(z));\\n  float weightZ = z - float(integerZ);\\n\\n  float v1 = generateNoise(integerX, integerY, integerZ, numOctave);\\n  float v2 = generateNoise(integerX, integerY, integerZ + 1, numOctave);\\n  float v3 = generateNoise(integerX, integerY + 1, integerZ + 1, numOctave);\\n  float v4 = generateNoise(integerX, integerY + 1, integerZ, numOctave);\\n\\n  float v5 = generateNoise(integerX + 1, integerY, integerZ, numOctave);\\n  float v6 = generateNoise(integerX + 1, integerY, integerZ + 1, numOctave);\\n  float v7 = generateNoise(integerX + 1, integerY + 1, integerZ + 1, numOctave);\\n  float v8 = generateNoise(integerX + 1, integerY + 1, integerZ, numOctave);\\n\\n  float i1 = cosineInterpolate(v1, v5, weightX);\\n  float i2 = cosineInterpolate(v2, v6, weightX);\\n  float i3 = cosineInterpolate(v3, v7, weightX);\\n  float i4 = cosineInterpolate(v4, v8, weightX);\\n\\n  float ii1 = cosineInterpolate(i1, i4, weightY);\\n  float ii2 = cosineInterpolate(i2, i3, weightY);\\n\\n  return cosineInterpolate(ii1, ii2, weightZ);\\n}\\n\\n// a multi-octave noise generation function that sums multiple noise functions together\\n// with each subsequent noise function increasing in frequency and decreasing in amplitude\\nfloat generateMultiOctaveNoise(float x, float y, float z) {\\n  float total = 0.0;\\n  float persistence = 1.0 / noiseStrength;\\n\\n    //loop for some number of octaves\\n  for(int i = 0; i < aLargeNumber; i++) {\\n    if(i == numOctaves)\\n      break;\\n    float frequency = pow(2.0, float(i));\\n    float amplitude = pow(persistence, float(i));\\n\\n    total += interpolateNoise(x * frequency, y * frequency, z * frequency, i) * amplitude;\\n  }\\n\\n  return total;\\n}\\n\\nvoid main() {\\n  float offset = generateMultiOctaveNoise(position[0] + time / 999.0, position[1] + time / 999.0, position[2] + time / 999.0);\\n  vec3 newPosition = position + offset * normal * audioScale;\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\\n  vUv = uv;\\n  vNormal = normal;\\n  vNoise = offset;\\n}\";"},"lineCount":null}},"error":null,"hash":"6f95cff99d5f3d45fe2f8d202c40b0c5","cacheData":{"env":{}}}