{"id":"src/assets/libs/shaders/song/Songfragment.glsl","dependencies":[{"name":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\package.json","includedInParent":true,"mtime":1624327498692}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\n// varying vec2 vUv;\\n// varying float vNoise;\\n// varying vec3 vNormal;\\n\\n// float linearInterpolate(float a, float b, float t) {\\n//   return a * (1.0 - t) + b * t;\\n// }\\n\\n// void main() {\\n//   float r = linearInterpolate(0.0, 0.9, vNoise);\\n//   float g = linearInterpolate(0.0, 0.9, vNoise);\\n//   float b = linearInterpolate(0.0, 0.9, vNoise);\\n\\n//     // gl_FragColor = vec4(r, g, b, 1.0);\\n//   gl_FragColor = vec4(vUv.x, 1.0, vUv.y, 1.0);\\n// }\\n\\nuniform float time;\\nuniform vec2 uResolution;\\n\\nfloat colormap_red(float x) {\\n  if(x < 0.0) {\\n    return 54.0 / 255.0;\\n  } else if(x < 20049.0 / 82979.0) {\\n    return (829.79 * x + 54.51) / 255.0;\\n  } else {\\n    return 1.0;\\n  }\\n}\\n\\nfloat colormap_green(float x) {\\n  if(x < 20049.0 / 82979.0) {\\n    return 0.0;\\n  } else if(x < 327013.0 / 810990.0) {\\n    return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\\n  } else if(x <= 1.0) {\\n    return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\\n  } else {\\n    return 1.0;\\n  }\\n}\\n\\nfloat colormap_blue(float x) {\\n  if(x < 0.0) {\\n    return 54.0 / 255.0;\\n  } else if(x < 7249.0 / 82979.0) {\\n    return (829.79 * x + 54.51) / 255.0;\\n  } else if(x < 20049.0 / 82979.0) {\\n    return 127.0 / 255.0;\\n  } else if(x < 327013.0 / 810990.0) {\\n    return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\\n  } else {\\n    return 1.0;\\n  }\\n}\\n\\nvec4 colormap(float x) {\\n  return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\\n}\\n\\nfloat rand(vec2 n) {\\n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\\n}\\n\\nfloat noise(vec2 p) {\\n  vec2 ip = floor(p);\\n  vec2 u = fract(p);\\n  u = u * u * (3.0 - 2.0 * u);\\n\\n  float res = mix(mix(rand(ip), rand(ip + vec2(1.0, 0.0)), u.x), mix(rand(ip + vec2(0.0, 1.0)), rand(ip + vec2(1.0, 1.0)), u.x), u.y);\\n  return res * res;\\n}\\n\\nconst mat2 mtx = mat2(0.80, 0.60, -0.60, 0.80);\\n\\nfloat fbm(vec2 p) {\\n  float f = 0.0;\\n\\n  f += 0.500000 * noise(p + time / 1000.);\\n  p = mtx * p * 2.02;\\n  f += 0.031250 * noise(p);\\n  p = mtx * p * 2.01;\\n  f += 0.250000 * noise(p);\\n  p = mtx * p * 2.03;\\n  f += 0.125000 * noise(p);\\n  p = mtx * p * 2.01;\\n  f += 0.062500 * noise(p);\\n  p = mtx * p * 2.04;\\n  f += 0.015625 * noise(p + sin(time));\\n\\n  return f / 0.96875;\\n}\\n\\nfloat pattern(in vec2 p) {\\n  return fbm(p + fbm(p + fbm(p)));\\n}\\n\\nvoid main() {\\n  vec2 fragCoord = gl_FragCoord.xy;\\n  vec2 uv = fragCoord / uResolution.xy;\\n  float shade = pattern(uv);\\n  gl_FragColor = vec4(colormap(shade).rgb, shade);\\n}\\n\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"src/assets/libs/shaders/song/Songfragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"src/assets/libs/shaders/song/Songfragment.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"src/assets/libs/shaders/song/Songfragment.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"src/assets/libs/shaders/song/Songfragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"src/assets/libs/shaders/song/Songfragment.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":2637},"source":"src/assets/libs/shaders/song/Songfragment.glsl","original":{"line":1,"column":0}}],"sources":{"src/assets/libs/shaders/song/Songfragment.glsl":"module.exports=\"#define GLSLIFY 1\\n// varying vec2 vUv;\\n// varying float vNoise;\\n// varying vec3 vNormal;\\n\\n// float linearInterpolate(float a, float b, float t) {\\n//   return a * (1.0 - t) + b * t;\\n// }\\n\\n// void main() {\\n//   float r = linearInterpolate(0.0, 0.9, vNoise);\\n//   float g = linearInterpolate(0.0, 0.9, vNoise);\\n//   float b = linearInterpolate(0.0, 0.9, vNoise);\\n\\n//     // gl_FragColor = vec4(r, g, b, 1.0);\\n//   gl_FragColor = vec4(vUv.x, 1.0, vUv.y, 1.0);\\n// }\\n\\nuniform float time;\\nuniform vec2 uResolution;\\n\\nfloat colormap_red(float x) {\\n  if(x < 0.0) {\\n    return 54.0 / 255.0;\\n  } else if(x < 20049.0 / 82979.0) {\\n    return (829.79 * x + 54.51) / 255.0;\\n  } else {\\n    return 1.0;\\n  }\\n}\\n\\nfloat colormap_green(float x) {\\n  if(x < 20049.0 / 82979.0) {\\n    return 0.0;\\n  } else if(x < 327013.0 / 810990.0) {\\n    return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\\n  } else if(x <= 1.0) {\\n    return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\\n  } else {\\n    return 1.0;\\n  }\\n}\\n\\nfloat colormap_blue(float x) {\\n  if(x < 0.0) {\\n    return 54.0 / 255.0;\\n  } else if(x < 7249.0 / 82979.0) {\\n    return (829.79 * x + 54.51) / 255.0;\\n  } else if(x < 20049.0 / 82979.0) {\\n    return 127.0 / 255.0;\\n  } else if(x < 327013.0 / 810990.0) {\\n    return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\\n  } else {\\n    return 1.0;\\n  }\\n}\\n\\nvec4 colormap(float x) {\\n  return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\\n}\\n\\nfloat rand(vec2 n) {\\n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\\n}\\n\\nfloat noise(vec2 p) {\\n  vec2 ip = floor(p);\\n  vec2 u = fract(p);\\n  u = u * u * (3.0 - 2.0 * u);\\n\\n  float res = mix(mix(rand(ip), rand(ip + vec2(1.0, 0.0)), u.x), mix(rand(ip + vec2(0.0, 1.0)), rand(ip + vec2(1.0, 1.0)), u.x), u.y);\\n  return res * res;\\n}\\n\\nconst mat2 mtx = mat2(0.80, 0.60, -0.60, 0.80);\\n\\nfloat fbm(vec2 p) {\\n  float f = 0.0;\\n\\n  f += 0.500000 * noise(p + time / 1000.);\\n  p = mtx * p * 2.02;\\n  f += 0.031250 * noise(p);\\n  p = mtx * p * 2.01;\\n  f += 0.250000 * noise(p);\\n  p = mtx * p * 2.03;\\n  f += 0.125000 * noise(p);\\n  p = mtx * p * 2.01;\\n  f += 0.062500 * noise(p);\\n  p = mtx * p * 2.04;\\n  f += 0.015625 * noise(p + sin(time));\\n\\n  return f / 0.96875;\\n}\\n\\nfloat pattern(in vec2 p) {\\n  return fbm(p + fbm(p + fbm(p)));\\n}\\n\\nvoid main() {\\n  vec2 fragCoord = gl_FragCoord.xy;\\n  vec2 uv = fragCoord / uResolution.xy;\\n  float shade = pattern(uv);\\n  gl_FragColor = vec4(colormap(shade).rgb, shade);\\n}\\n\";"},"lineCount":null}},"error":null,"hash":"ff371b77d3718e3b70086d0ea7e1e2e3","cacheData":{"env":{}}}