{"id":"node_modules/av/src/demuxers/m4a.coffee","dependencies":[{"name":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\package.json","includedInParent":true,"mtime":1624288368876},{"name":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\node_modules\\av\\package.json","includedInParent":true,"mtime":1624288427802},{"name":"../demuxer","loc":{"line":5,"column":20},"parent":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\node_modules\\av\\src\\demuxers\\m4a.coffee","resolved":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\node_modules\\av\\src\\demuxer.coffee"}],"generated":{"js":"(function() {\n  var Demuxer, M4ADemuxer,\n    indexOf = [].indexOf;\n\n  Demuxer = require('../demuxer');\n\n  M4ADemuxer = (function() {\n    var BITS_PER_CHANNEL, TYPES, after, atom, atoms, bool, containers, diskTrack, genres, meta, string;\n\n    class M4ADemuxer extends Demuxer {\n      static probe(buffer) {\n        var ref;\n        return buffer.peekString(4, 4) === 'ftyp' && (ref = buffer.peekString(8, 4), indexOf.call(TYPES, ref) >= 0);\n      }\n\n      init() {\n        // current atom heirarchy stacks\n        this.atoms = [];\n        this.offsets = [];\n        \n        // m4a files can have multiple tracks\n        this.track = null;\n        return this.tracks = [];\n      }\n\n      readChunk() {\n        var handler, path, type;\n        this.break = false;\n        while (this.stream.available(1) && !this.break) {\n          // if we're ready to read a new atom, add it to the stack\n          if (!this.readHeaders) {\n            if (!this.stream.available(8)) {\n              return;\n            }\n            this.len = this.stream.readUInt32() - 8;\n            this.type = this.stream.readString(4);\n            if (this.len === 0) {\n              continue;\n            }\n            this.atoms.push(this.type);\n            this.offsets.push(this.stream.offset + this.len);\n            this.readHeaders = true;\n          }\n          \n          // find a handler for the current atom heirarchy\n          path = this.atoms.join('.');\n          handler = atoms[path];\n          if (handler != null ? handler.fn : void 0) {\n            // wait until we have enough data, unless this is the mdat atom\n            if (!(this.stream.available(this.len) || path === 'mdat')) {\n              return;\n            }\n            // call the parser for the atom type\n            handler.fn.call(this);\n            \n            // check if this atom can contain sub-atoms\n            if (path in containers) {\n              this.readHeaders = false;\n            }\n          \n          // handle container atoms\n          } else if (path in containers) {\n            this.readHeaders = false;\n          } else {\n            // wait until we have enough data\n\n            // unknown atom\n            if (!this.stream.available(this.len)) {\n              return;\n            }\n            this.stream.advance(this.len);\n          }\n          \n            // pop completed items from the stack\n          while (this.stream.offset >= this.offsets[this.offsets.length - 1]) {\n            // call after handler\n            handler = atoms[this.atoms.join('.')];\n            if (handler != null ? handler.after : void 0) {\n              handler.after.call(this);\n            }\n            type = this.atoms.pop();\n            this.offsets.pop();\n            this.readHeaders = false;\n          }\n        }\n      }\n\n      \n        // reads a variable length integer\n      static readDescrLen(stream) {\n        var c, count, len;\n        len = 0;\n        count = 4;\n        while (count--) {\n          c = stream.readUInt8();\n          len = (len << 7) | (c & 0x7f);\n          if (!(c & 0x80)) {\n            break;\n          }\n        }\n        return len;\n      }\n\n      static readEsds(stream) {\n        var codec_id, flags, len, tag;\n        stream.advance(4); // version and flags\n        tag = stream.readUInt8();\n        len = M4ADemuxer.readDescrLen(stream);\n        if (tag === 0x03) { // MP4ESDescrTag\n          stream.advance(2); // id\n          flags = stream.readUInt8();\n          if (flags & 0x80) { // streamDependenceFlag\n            stream.advance(2);\n          }\n          if (flags & 0x40) { // URL_Flag\n            stream.advance(stream.readUInt8());\n          }\n          if (flags & 0x20) { // OCRstreamFlag\n            stream.advance(2);\n          }\n        } else {\n          stream.advance(2); // id\n        }\n        tag = stream.readUInt8();\n        len = M4ADemuxer.readDescrLen(stream);\n        if (tag === 0x04) { // MP4DecConfigDescrTag\n          codec_id = stream.readUInt8(); // might want this... (isom.c:35)\n          stream.advance(1); // stream type\n          stream.advance(3); // buffer size\n          stream.advance(4); // max bitrate\n          stream.advance(4); // avg bitrate\n          tag = stream.readUInt8();\n          len = M4ADemuxer.readDescrLen(stream);\n          if (tag === 0x05) { // MP4DecSpecificDescrTag\n            return stream.readBuffer(len);\n          }\n        }\n        return null;\n      }\n\n      \n        // once we have all the information we need, generate the seek table for this track\n      setupSeekPoints() {\n        var i, j, k, l, len1, offset, position, ref, ref1, results, sampleIndex, size, stscIndex, sttsIndex, sttsSample, timestamp;\n        if (!((this.track.chunkOffsets != null) && (this.track.stsc != null) && (this.track.sampleSize != null) && (this.track.stts != null))) {\n          return;\n        }\n        stscIndex = 0;\n        sttsIndex = 0;\n        sttsIndex = 0;\n        sttsSample = 0;\n        sampleIndex = 0;\n        offset = 0;\n        timestamp = 0;\n        this.track.seekPoints = [];\n        ref = this.track.chunkOffsets;\n        results = [];\n        for (i = k = 0, len1 = ref.length; k < len1; i = ++k) {\n          position = ref[i];\n          for (j = l = 0, ref1 = this.track.stsc[stscIndex].count; l < ref1; j = l += 1) {\n            // push the timestamp and both the physical position in the file\n            // and the offset without gaps from the start of the data\n            this.track.seekPoints.push({\n              offset: offset,\n              position: position,\n              timestamp: timestamp\n            });\n            size = this.track.sampleSize || this.track.sampleSizes[sampleIndex++];\n            offset += size;\n            position += size;\n            timestamp += this.track.stts[sttsIndex].duration;\n            if (sttsIndex + 1 < this.track.stts.length && ++sttsSample === this.track.stts[sttsIndex].count) {\n              sttsSample = 0;\n              sttsIndex++;\n            }\n          }\n          if (stscIndex + 1 < this.track.stsc.length && i + 1 === this.track.stsc[stscIndex + 1].first) {\n            results.push(stscIndex++);\n          } else {\n            results.push(void 0);\n          }\n        }\n        return results;\n      }\n\n      parseChapters() {\n        var bom, id, k, len, len1, nextTimestamp, point, ref, ref1, ref2, ref3, title, track;\n        if (!(((ref = this.track.chapterTracks) != null ? ref.length : void 0) > 0)) {\n          return true;\n        }\n        // find the chapter track\n        id = this.track.chapterTracks[0];\n        ref1 = this.tracks;\n        for (k = 0, len1 = ref1.length; k < len1; k++) {\n          track = ref1[k];\n          if (track.id === id) {\n            break;\n          }\n        }\n        if (track.id !== id) {\n          this.emit('error', 'Chapter track does not exist.');\n        }\n        if (this.chapters == null) {\n          this.chapters = [];\n        }\n        \n          // use the seek table offsets to find chapter titles\n        while (this.chapters.length < track.seekPoints.length) {\n          point = track.seekPoints[this.chapters.length];\n          if (!this.stream.available(point.position - this.stream.offset + 32)) {\n            \n            // make sure we have enough data\n            return false;\n          }\n          // jump to the title offset\n          this.stream.seek(point.position);\n          // read the length of the title string\n          len = this.stream.readUInt16();\n          title = null;\n          if (!this.stream.available(len)) {\n            return false;\n          }\n          \n          // if there is a BOM marker, read a utf16 string\n          if (len > 2) {\n            bom = this.stream.peekUInt16();\n            if (bom === 0xfeff || bom === 0xfffe) {\n              title = this.stream.readString(len, 'utf16-bom');\n            }\n          }\n          // otherwise, use utf8\n          if (title == null) {\n            title = this.stream.readString(len, 'utf8');\n          }\n          \n          // add the chapter title, timestamp, and duration\n          nextTimestamp = (ref2 = (ref3 = track.seekPoints[this.chapters.length + 1]) != null ? ref3.timestamp : void 0) != null ? ref2 : track.duration;\n          this.chapters.push({\n            title: title,\n            timestamp: point.timestamp / track.timeScale * 1000 | 0,\n            duration: (nextTimestamp - point.timestamp) / track.timeScale * 1000 | 0\n          });\n        }\n        \n        // we're done, so emit the chapter data\n        this.emit('chapters', this.chapters);\n        return true;\n      }\n\n    };\n\n    Demuxer.register(M4ADemuxer);\n\n    \n    // common file type identifiers\n    // see http://mp4ra.org/filetype.html for a complete list\n    TYPES = ['M4A ', 'M4P ', 'M4B ', 'M4V ', 'isom', 'mp42', 'qt  '];\n\n    \n    // lookup table for atom handlers\n    atoms = {};\n\n    \n    // lookup table of container atom names\n    containers = {};\n\n    \n    // declare a function to be used for parsing a given atom name\n    atom = function(name, fn) {\n      var c, container, k, len1, ref;\n      c = [];\n      ref = name.split('.').slice(0, -1);\n      for (k = 0, len1 = ref.length; k < len1; k++) {\n        container = ref[k];\n        c.push(container);\n        containers[c.join('.')] = true;\n      }\n      if (atoms[name] == null) {\n        atoms[name] = {};\n      }\n      return atoms[name].fn = fn;\n    };\n\n    \n    // declare a function to be called after parsing of an atom and all sub-atoms has completed\n    after = function(name, fn) {\n      if (atoms[name] == null) {\n        atoms[name] = {};\n      }\n      return atoms[name].after = fn;\n    };\n\n    atom('ftyp', function() {\n      var ref;\n      if (ref = this.stream.readString(4), indexOf.call(TYPES, ref) < 0) {\n        return this.emit('error', 'Not a valid M4A file.');\n      }\n      return this.stream.advance(this.len - 4);\n    });\n\n    atom('moov.trak', function() {\n      this.track = {};\n      return this.tracks.push(this.track);\n    });\n\n    atom('moov.trak.tkhd', function() {\n      this.stream.advance(4); // version and flags\n      this.stream.advance(8); // creation and modification time\n      this.track.id = this.stream.readUInt32();\n      return this.stream.advance(this.len - 16);\n    });\n\n    atom('moov.trak.mdia.hdlr', function() {\n      this.stream.advance(4); // version and flags\n      this.stream.advance(4); // component type\n      this.track.type = this.stream.readString(4);\n      this.stream.advance(12); // component manufacturer, flags, and mask\n      return this.stream.advance(this.len - 24); // component name\n    });\n\n    atom('moov.trak.mdia.mdhd', function() {\n      this.stream.advance(4); // version and flags\n      this.stream.advance(8); // creation and modification dates\n      this.track.timeScale = this.stream.readUInt32();\n      this.track.duration = this.stream.readUInt32();\n      return this.stream.advance(4); // language and quality\n    });\n\n    \n    // corrections to bits per channel, base on formatID\n    // (ffmpeg appears to always encode the bitsPerChannel as 16)\n    BITS_PER_CHANNEL = {\n      ulaw: 8,\n      alaw: 8,\n      in24: 24,\n      in32: 32,\n      fl32: 32,\n      fl64: 64\n    };\n\n    atom('moov.trak.mdia.minf.stbl.stsd', function() {\n      var format, numEntries, ref, ref1, version;\n      this.stream.advance(4); // version and flags\n      numEntries = this.stream.readUInt32();\n      \n      // just ignore the rest of the atom if this isn't an audio track\n      if (this.track.type !== 'soun') {\n        return this.stream.advance(this.len - 8);\n      }\n      if (numEntries !== 1) {\n        return this.emit('error', \"Only expecting one entry in sample description atom!\");\n      }\n      this.stream.advance(4); // size\n      format = this.track.format = {};\n      format.formatID = this.stream.readString(4);\n      this.stream.advance(6); // reserved\n      this.stream.advance(2); // data reference index\n      version = this.stream.readUInt16();\n      this.stream.advance(6); // skip revision level and vendor\n      format.channelsPerFrame = this.stream.readUInt16();\n      format.bitsPerChannel = this.stream.readUInt16();\n      this.stream.advance(4); // skip compression id and packet size\n      format.sampleRate = this.stream.readUInt16();\n      this.stream.advance(2);\n      if (version === 1) {\n        format.framesPerPacket = this.stream.readUInt32();\n        this.stream.advance(4); // bytes per packet\n        format.bytesPerFrame = this.stream.readUInt32();\n        this.stream.advance(4); // bytes per sample\n      } else if (version !== 0) {\n        this.emit('error', 'Unknown version in stsd atom');\n      }\n      if (BITS_PER_CHANNEL[format.formatID] != null) {\n        format.bitsPerChannel = BITS_PER_CHANNEL[format.formatID];\n      }\n      format.floatingPoint = (ref = format.formatID) === 'fl32' || ref === 'fl64';\n      format.littleEndian = format.formatID === 'sowt' && format.bitsPerChannel > 8;\n      if ((ref1 = format.formatID) === 'twos' || ref1 === 'sowt' || ref1 === 'in24' || ref1 === 'in32' || ref1 === 'fl32' || ref1 === 'fl64' || ref1 === 'raw ' || ref1 === 'NONE') {\n        return format.formatID = 'lpcm';\n      }\n    });\n\n    atom('moov.trak.mdia.minf.stbl.stsd.alac', function() {\n      this.stream.advance(4);\n      return this.track.cookie = this.stream.readBuffer(this.len - 4);\n    });\n\n    atom('moov.trak.mdia.minf.stbl.stsd.esds', function() {\n      var offset;\n      offset = this.stream.offset + this.len;\n      this.track.cookie = M4ADemuxer.readEsds(this.stream);\n      return this.stream.seek(offset); // skip garbage at the end \n    });\n\n    atom('moov.trak.mdia.minf.stbl.stsd.wave.enda', function() {\n      return this.track.format.littleEndian = !!this.stream.readUInt16();\n    });\n\n    \n    // time to sample\n    atom('moov.trak.mdia.minf.stbl.stts', function() {\n      var entries, i, k, ref;\n      this.stream.advance(4); // version and flags\n      entries = this.stream.readUInt32();\n      this.track.stts = [];\n      for (i = k = 0, ref = entries; k < ref; i = k += 1) {\n        this.track.stts[i] = {\n          count: this.stream.readUInt32(),\n          duration: this.stream.readUInt32()\n        };\n      }\n      return this.setupSeekPoints();\n    });\n\n    \n    // sample to chunk\n    atom('moov.trak.mdia.minf.stbl.stsc', function() {\n      var entries, i, k, ref;\n      this.stream.advance(4); // version and flags\n      entries = this.stream.readUInt32();\n      this.track.stsc = [];\n      for (i = k = 0, ref = entries; k < ref; i = k += 1) {\n        this.track.stsc[i] = {\n          first: this.stream.readUInt32(),\n          count: this.stream.readUInt32(),\n          id: this.stream.readUInt32()\n        };\n      }\n      return this.setupSeekPoints();\n    });\n\n    \n    // sample size\n    atom('moov.trak.mdia.minf.stbl.stsz', function() {\n      var entries, i, k, ref;\n      this.stream.advance(4); // version and flags\n      this.track.sampleSize = this.stream.readUInt32();\n      entries = this.stream.readUInt32();\n      if (this.track.sampleSize === 0 && entries > 0) {\n        this.track.sampleSizes = [];\n        for (i = k = 0, ref = entries; k < ref; i = k += 1) {\n          this.track.sampleSizes[i] = this.stream.readUInt32();\n        }\n      }\n      return this.setupSeekPoints();\n    });\n\n    \n    // chunk offsets\n    atom('moov.trak.mdia.minf.stbl.stco', function() { // TODO: co64\n      var entries, i, k, ref;\n      this.stream.advance(4); // version and flags\n      entries = this.stream.readUInt32();\n      this.track.chunkOffsets = [];\n      for (i = k = 0, ref = entries; k < ref; i = k += 1) {\n        this.track.chunkOffsets[i] = this.stream.readUInt32();\n      }\n      return this.setupSeekPoints();\n    });\n\n    \n    // chapter track reference\n    atom('moov.trak.tref.chap', function() {\n      var entries, i, k, ref;\n      entries = this.len >> 2;\n      this.track.chapterTracks = [];\n      for (i = k = 0, ref = entries; k < ref; i = k += 1) {\n        this.track.chapterTracks[i] = this.stream.readUInt32();\n      }\n    });\n\n    after('moov', function() {\n      var k, len1, ref, track;\n      \n      // if the mdat block was at the beginning rather than the end, jump back to it\n      if (this.mdatOffset != null) {\n        this.stream.seek(this.mdatOffset - 8);\n      }\n      ref = this.tracks;\n      \n      // choose a track\n      for (k = 0, len1 = ref.length; k < len1; k++) {\n        track = ref[k];\n        if (!(track.type === 'soun')) {\n          continue;\n        }\n        this.track = track;\n        break;\n      }\n      if (this.track.type !== 'soun') {\n        this.track = null;\n        return this.emit('error', 'No audio tracks in m4a file.');\n      }\n      \n      // emit info\n      this.emit('format', this.track.format);\n      this.emit('duration', this.track.duration / this.track.timeScale * 1000 | 0);\n      if (this.track.cookie) {\n        this.emit('cookie', this.track.cookie);\n      }\n      \n      // use the seek points from the selected track\n      return this.seekPoints = this.track.seekPoints;\n    });\n\n    atom('mdat', function() {\n      var bytes, chunkSize, k, length, numSamples, offset, ref, sample, size;\n      if (!this.startedData) {\n        if (this.mdatOffset == null) {\n          this.mdatOffset = this.stream.offset;\n        }\n        \n        // if we haven't read the headers yet, the mdat atom was at the beginning\n        // rather than the end. Skip over it for now to read the headers first, and\n        // come back later.\n        if (this.tracks.length === 0) {\n          bytes = Math.min(this.stream.remainingBytes(), this.len);\n          this.stream.advance(bytes);\n          this.len -= bytes;\n          return;\n        }\n        this.chunkIndex = 0;\n        this.stscIndex = 0;\n        this.sampleIndex = 0;\n        this.tailOffset = 0;\n        this.tailSamples = 0;\n        this.startedData = true;\n      }\n      \n      // read the chapter information if any\n      if (!this.readChapters) {\n        this.readChapters = this.parseChapters();\n        if (this.break = !this.readChapters) {\n          return;\n        }\n        this.stream.seek(this.mdatOffset);\n      }\n      \n      // get the starting offset\n      offset = this.track.chunkOffsets[this.chunkIndex] + this.tailOffset;\n      length = 0;\n      \n      // make sure we have enough data to get to the offset\n      if (!this.stream.available(offset - this.stream.offset)) {\n        this.break = true;\n        return;\n      }\n      \n      // seek to the offset\n      this.stream.seek(offset);\n      \n        // calculate the maximum length we can read at once\n      while (this.chunkIndex < this.track.chunkOffsets.length) {\n        // calculate the size in bytes of the chunk using the sample size table\n        numSamples = this.track.stsc[this.stscIndex].count - this.tailSamples;\n        chunkSize = 0;\n        for (sample = k = 0, ref = numSamples; k < ref; sample = k += 1) {\n          size = this.track.sampleSize || this.track.sampleSizes[this.sampleIndex];\n          if (!this.stream.available(length + size)) {\n            \n            // if we don't have enough data to add this sample, jump out\n            break;\n          }\n          length += size;\n          chunkSize += size;\n          this.sampleIndex++;\n        }\n        \n        // if we didn't make it through the whole chunk, add what we did use to the tail\n        if (sample < numSamples) {\n          this.tailOffset += chunkSize;\n          this.tailSamples += sample;\n          break;\n        } else {\n          // otherwise, we can move to the next chunk\n          this.chunkIndex++;\n          this.tailOffset = 0;\n          this.tailSamples = 0;\n          \n          // if we've made it to the end of a list of subsequent chunks with the same number of samples,\n          // go to the next sample to chunk entry\n          if (this.stscIndex + 1 < this.track.stsc.length && this.chunkIndex + 1 === this.track.stsc[this.stscIndex + 1].first) {\n            this.stscIndex++;\n          }\n          \n          // if the next chunk isn't right after this one, jump out\n          if (offset + length !== this.track.chunkOffsets[this.chunkIndex]) {\n            break;\n          }\n        }\n      }\n      \n      // emit some data if we have any, otherwise wait for more\n      if (length > 0) {\n        this.emit('data', this.stream.readBuffer(length));\n        return this.break = this.chunkIndex === this.track.chunkOffsets.length;\n      } else {\n        return this.break = true;\n      }\n    });\n\n    \n    // metadata chunk\n    atom('moov.udta.meta', function() {\n      this.metadata = {};\n      return this.stream.advance(4); // version and flags\n    });\n\n    \n    // emit when we're done\n    after('moov.udta.meta', function() {\n      return this.emit('metadata', this.metadata);\n    });\n\n    // convienience function to generate metadata atom handler\n    meta = function(field, name, fn) {\n      return atom(`moov.udta.meta.ilst.${field}.data`, function() {\n        this.stream.advance(8);\n        this.len -= 8;\n        return fn.call(this, name);\n      });\n    };\n\n    // string field reader\n    string = function(field) {\n      return this.metadata[field] = this.stream.readString(this.len, 'utf8');\n    };\n\n    // from http://atomicparsley.sourceforge.net/mpeg-4files.html\n    meta('©alb', 'album', string);\n\n    meta('©arg', 'arranger', string);\n\n    meta('©art', 'artist', string);\n\n    meta('©ART', 'artist', string);\n\n    meta('aART', 'albumArtist', string);\n\n    meta('catg', 'category', string);\n\n    meta('©com', 'composer', string);\n\n    meta('©cpy', 'copyright', string);\n\n    meta('cprt', 'copyright', string);\n\n    meta('©cmt', 'comments', string);\n\n    meta('©day', 'releaseDate', string);\n\n    meta('desc', 'description', string);\n\n    meta('©gen', 'genre', string); // custom genres\n\n    meta('©grp', 'grouping', string);\n\n    meta('©isr', 'ISRC', string);\n\n    meta('keyw', 'keywords', string);\n\n    meta('©lab', 'recordLabel', string);\n\n    meta('ldes', 'longDescription', string);\n\n    meta('©lyr', 'lyrics', string);\n\n    meta('©nam', 'title', string);\n\n    meta('©phg', 'recordingCopyright', string);\n\n    meta('©prd', 'producer', string);\n\n    meta('©prf', 'performers', string);\n\n    meta('purd', 'purchaseDate', string);\n\n    meta('purl', 'podcastURL', string);\n\n    meta('©swf', 'songwriter', string);\n\n    meta('©too', 'encoder', string);\n\n    meta('©wrt', 'composer', string);\n\n    meta('covr', 'coverArt', function(field) {\n      return this.metadata[field] = this.stream.readBuffer(this.len);\n    });\n\n    // standard genres\n    genres = [\"Blues\", \"Classic Rock\", \"Country\", \"Dance\", \"Disco\", \"Funk\", \"Grunge\", \"Hip-Hop\", \"Jazz\", \"Metal\", \"New Age\", \"Oldies\", \"Other\", \"Pop\", \"R&B\", \"Rap\", \"Reggae\", \"Rock\", \"Techno\", \"Industrial\", \"Alternative\", \"Ska\", \"Death Metal\", \"Pranks\", \"Soundtrack\", \"Euro-Techno\", \"Ambient\", \"Trip-Hop\", \"Vocal\", \"Jazz+Funk\", \"Fusion\", \"Trance\", \"Classical\", \"Instrumental\", \"Acid\", \"House\", \"Game\", \"Sound Clip\", \"Gospel\", \"Noise\", \"AlternRock\", \"Bass\", \"Soul\", \"Punk\", \"Space\", \"Meditative\", \"Instrumental Pop\", \"Instrumental Rock\", \"Ethnic\", \"Gothic\", \"Darkwave\", \"Techno-Industrial\", \"Electronic\", \"Pop-Folk\", \"Eurodance\", \"Dream\", \"Southern Rock\", \"Comedy\", \"Cult\", \"Gangsta\", \"Top 40\", \"Christian Rap\", \"Pop/Funk\", \"Jungle\", \"Native American\", \"Cabaret\", \"New Wave\", \"Psychadelic\", \"Rave\", \"Showtunes\", \"Trailer\", \"Lo-Fi\", \"Tribal\", \"Acid Punk\", \"Acid Jazz\", \"Polka\", \"Retro\", \"Musical\", \"Rock & Roll\", \"Hard Rock\", \"Folk\", \"Folk/Rock\", \"National Folk\", \"Swing\", \"Fast Fusion\", \"Bebob\", \"Latin\", \"Revival\", \"Celtic\", \"Bluegrass\", \"Avantgarde\", \"Gothic Rock\", \"Progressive Rock\", \"Psychedelic Rock\", \"Symphonic Rock\", \"Slow Rock\", \"Big Band\", \"Chorus\", \"Easy Listening\", \"Acoustic\", \"Humour\", \"Speech\", \"Chanson\", \"Opera\", \"Chamber Music\", \"Sonata\", \"Symphony\", \"Booty Bass\", \"Primus\", \"Porn Groove\", \"Satire\", \"Slow Jam\", \"Club\", \"Tango\", \"Samba\", \"Folklore\", \"Ballad\", \"Power Ballad\", \"Rhythmic Soul\", \"Freestyle\", \"Duet\", \"Punk Rock\", \"Drum Solo\", \"A Capella\", \"Euro-House\", \"Dance Hall\"];\n\n    meta('gnre', 'genre', function(field) {\n      return this.metadata[field] = genres[this.stream.readUInt16() - 1];\n    });\n\n    meta('tmpo', 'tempo', function(field) {\n      return this.metadata[field] = this.stream.readUInt16();\n    });\n\n    meta('rtng', 'rating', function(field) {\n      var rating;\n      rating = this.stream.readUInt8();\n      return this.metadata[field] = rating === 2 ? 'Clean' : rating !== 0 ? 'Explicit' : 'None';\n    });\n\n    diskTrack = function(field) {\n      this.stream.advance(2);\n      this.metadata[field] = this.stream.readUInt16() + ' of ' + this.stream.readUInt16();\n      return this.stream.advance(this.len - 6);\n    };\n\n    meta('disk', 'diskNumber', diskTrack);\n\n    meta('trkn', 'trackNumber', diskTrack);\n\n    bool = function(field) {\n      return this.metadata[field] = this.stream.readUInt8() === 1;\n    };\n\n    meta('cpil', 'compilation', bool);\n\n    meta('pcst', 'podcast', bool);\n\n    meta('pgap', 'gapless', bool);\n\n    return M4ADemuxer;\n\n  }).call(this);\n\n  module.exports = M4ADemuxer;\n\n}).call(this);\n"},"sourceMaps":{"js":{"version":3,"file":"","sourceRoot":"","sources":["node_modules/av/src/demuxers/m4a.coffee"],"names":[],"mappings":"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","sourcesContent":["Demuxer = require '../demuxer'\n\nclass M4ADemuxer extends Demuxer\n    Demuxer.register(M4ADemuxer)\n    \n    # common file type identifiers\n    # see http://mp4ra.org/filetype.html for a complete list\n    TYPES = ['M4A ', 'M4P ', 'M4B ', 'M4V ', 'isom', 'mp42', 'qt  ']\n    \n    @probe: (buffer) ->\n        return buffer.peekString(4, 4) is 'ftyp' and\n               buffer.peekString(8, 4) in TYPES\n        \n    init: ->\n        # current atom heirarchy stacks\n        @atoms = []\n        @offsets = []\n        \n        # m4a files can have multiple tracks\n        @track = null\n        @tracks = []\n        \n    # lookup table for atom handlers\n    atoms = {}\n    \n    # lookup table of container atom names\n    containers = {}\n    \n    # declare a function to be used for parsing a given atom name\n    atom = (name, fn) ->        \n        c = []\n        for container in name.split('.').slice(0, -1)\n            c.push container\n            containers[c.join('.')] = true\n            \n        atoms[name] ?= {}\n        atoms[name].fn = fn\n        \n    # declare a function to be called after parsing of an atom and all sub-atoms has completed\n    after = (name, fn) ->\n        atoms[name] ?= {}\n        atoms[name].after = fn\n        \n    readChunk: ->\n        @break = false\n        \n        while @stream.available(1) and not @break\n            # if we're ready to read a new atom, add it to the stack\n            if not @readHeaders\n                return unless @stream.available(8)\n                \n                @len = @stream.readUInt32() - 8\n                @type = @stream.readString(4)\n                \n                continue if @len is 0\n                \n                @atoms.push @type\n                @offsets.push @stream.offset + @len\n                @readHeaders = true\n                \n            # find a handler for the current atom heirarchy\n            path = @atoms.join '.'                \n            handler = atoms[path]\n            \n            if handler?.fn\n                # wait until we have enough data, unless this is the mdat atom\n                return unless @stream.available(@len) or path is 'mdat'\n\n                # call the parser for the atom type\n                handler.fn.call(this)\n                \n                # check if this atom can contain sub-atoms\n                if path of containers\n                    @readHeaders = false\n                    \n            # handle container atoms\n            else if path of containers\n                @readHeaders = false\n                \n            # unknown atom\n            else\n                # wait until we have enough data\n                return unless @stream.available(@len)\n                @stream.advance(@len)\n                \n            # pop completed items from the stack\n            while @stream.offset >= @offsets[@offsets.length - 1]\n                # call after handler\n                handler = atoms[@atoms.join '.']\n                if handler?.after\n                    handler.after.call(this)\n                \n                type = @atoms.pop()\n                @offsets.pop()\n                @readHeaders = false\n                \n    atom 'ftyp', ->\n        if @stream.readString(4) not in TYPES\n            return @emit 'error', 'Not a valid M4A file.'\n        \n        @stream.advance(@len - 4)\n    \n    atom 'moov.trak', ->\n        @track = {}\n        @tracks.push @track\n        \n    atom 'moov.trak.tkhd', ->\n        @stream.advance(4) # version and flags\n        \n        @stream.advance(8) # creation and modification time\n        @track.id = @stream.readUInt32()\n        \n        @stream.advance(@len - 16)\n        \n    atom 'moov.trak.mdia.hdlr', ->\n        @stream.advance(4) # version and flags\n        \n        @stream.advance(4) # component type\n        @track.type = @stream.readString(4)\n        \n        @stream.advance(12) # component manufacturer, flags, and mask\n        @stream.advance(@len - 24) # component name\n    \n    atom 'moov.trak.mdia.mdhd', ->\n        @stream.advance(4) # version and flags\n        @stream.advance(8) # creation and modification dates\n        \n        @track.timeScale = @stream.readUInt32()\n        @track.duration = @stream.readUInt32()\n        \n        @stream.advance(4) # language and quality\n        \n    # corrections to bits per channel, base on formatID\n    # (ffmpeg appears to always encode the bitsPerChannel as 16)\n    BITS_PER_CHANNEL = \n        ulaw: 8\n        alaw: 8\n        in24: 24\n        in32: 32\n        fl32: 32\n        fl64: 64\n        \n    atom 'moov.trak.mdia.minf.stbl.stsd', ->\n        @stream.advance(4) # version and flags\n        \n        numEntries = @stream.readUInt32()\n        \n        # just ignore the rest of the atom if this isn't an audio track\n        if @track.type isnt 'soun'\n            return @stream.advance(@len - 8)\n        \n        if numEntries isnt 1\n            return @emit 'error', \"Only expecting one entry in sample description atom!\"\n            \n        @stream.advance(4) # size\n        \n        format = @track.format = {}\n        format.formatID = @stream.readString(4)\n        \n        @stream.advance(6) # reserved\n        @stream.advance(2) # data reference index\n        \n        version = @stream.readUInt16()\n        @stream.advance(6) # skip revision level and vendor\n        \n        format.channelsPerFrame = @stream.readUInt16()\n        format.bitsPerChannel = @stream.readUInt16()\n        \n        @stream.advance(4) # skip compression id and packet size\n        \n        format.sampleRate = @stream.readUInt16()\n        @stream.advance(2)\n        \n        if version is 1\n            format.framesPerPacket = @stream.readUInt32()\n            @stream.advance(4) # bytes per packet\n            format.bytesPerFrame = @stream.readUInt32()\n            @stream.advance(4) # bytes per sample\n            \n        else if version isnt 0\n            @emit 'error', 'Unknown version in stsd atom'\n            \n        if BITS_PER_CHANNEL[format.formatID]?\n            format.bitsPerChannel = BITS_PER_CHANNEL[format.formatID]\n            \n        format.floatingPoint = format.formatID in ['fl32', 'fl64']\n        format.littleEndian = format.formatID is 'sowt' and format.bitsPerChannel > 8\n        \n        if format.formatID in ['twos', 'sowt', 'in24', 'in32', 'fl32', 'fl64', 'raw ', 'NONE']\n            format.formatID = 'lpcm'\n        \n    atom 'moov.trak.mdia.minf.stbl.stsd.alac', ->\n        @stream.advance(4)\n        @track.cookie = @stream.readBuffer(@len - 4)\n        \n    atom 'moov.trak.mdia.minf.stbl.stsd.esds', ->\n        offset = @stream.offset + @len\n        @track.cookie = M4ADemuxer.readEsds @stream\n        @stream.seek offset # skip garbage at the end \n        \n    atom 'moov.trak.mdia.minf.stbl.stsd.wave.enda', ->\n        @track.format.littleEndian = !!@stream.readUInt16()\n        \n    # reads a variable length integer\n    @readDescrLen: (stream) ->\n        len = 0\n        count = 4\n\n        while count--\n            c = stream.readUInt8()\n            len = (len << 7) | (c & 0x7f)\n            break unless c & 0x80\n\n        return len\n        \n    @readEsds: (stream) ->\n        stream.advance(4) # version and flags\n        \n        tag = stream.readUInt8()\n        len = M4ADemuxer.readDescrLen(stream)\n\n        if tag is 0x03 # MP4ESDescrTag\n            stream.advance(2) # id\n            flags = stream.readUInt8()\n\n            if flags & 0x80 # streamDependenceFlag\n                stream.advance(2)\n\n            if flags & 0x40 # URL_Flag\n                stream.advance stream.readUInt8()\n\n            if flags & 0x20 # OCRstreamFlag\n                stream.advance(2)\n\n        else\n            stream.advance(2) # id\n\n        tag = stream.readUInt8()\n        len = M4ADemuxer.readDescrLen(stream)\n            \n        if tag is 0x04 # MP4DecConfigDescrTag\n            codec_id = stream.readUInt8() # might want this... (isom.c:35)\n            stream.advance(1) # stream type\n            stream.advance(3) # buffer size\n            stream.advance(4) # max bitrate\n            stream.advance(4) # avg bitrate\n\n            tag = stream.readUInt8()\n            len = M4ADemuxer.readDescrLen(stream)\n            \n            if tag is 0x05 # MP4DecSpecificDescrTag\n                return stream.readBuffer(len)\n        \n        return null\n        \n    # time to sample\n    atom 'moov.trak.mdia.minf.stbl.stts', ->\n        @stream.advance(4) # version and flags\n        \n        entries = @stream.readUInt32()\n        @track.stts = []\n        for i in [0...entries] by 1\n            @track.stts[i] =\n                count: @stream.readUInt32()\n                duration: @stream.readUInt32()\n                \n        @setupSeekPoints()\n    \n    # sample to chunk\n    atom 'moov.trak.mdia.minf.stbl.stsc', ->\n        @stream.advance(4) # version and flags\n        \n        entries = @stream.readUInt32()\n        @track.stsc = []\n        for i in [0...entries] by 1\n            @track.stsc[i] = \n                first: @stream.readUInt32()\n                count: @stream.readUInt32()\n                id: @stream.readUInt32()\n                \n        @setupSeekPoints()\n        \n    # sample size\n    atom 'moov.trak.mdia.minf.stbl.stsz', ->\n        @stream.advance(4) # version and flags\n        \n        @track.sampleSize = @stream.readUInt32()\n        entries = @stream.readUInt32()\n        \n        if @track.sampleSize is 0 and entries > 0\n            @track.sampleSizes = []\n            for i in [0...entries] by 1\n                @track.sampleSizes[i] = @stream.readUInt32()\n                \n        @setupSeekPoints()\n    \n    # chunk offsets\n    atom 'moov.trak.mdia.minf.stbl.stco', -> # TODO: co64\n        @stream.advance(4) # version and flags\n        \n        entries = @stream.readUInt32()\n        @track.chunkOffsets = []\n        for i in [0...entries] by 1\n            @track.chunkOffsets[i] = @stream.readUInt32()\n            \n        @setupSeekPoints()\n        \n    # chapter track reference\n    atom 'moov.trak.tref.chap', ->\n        entries = @len >> 2\n        @track.chapterTracks = []\n        for i in [0...entries] by 1\n            @track.chapterTracks[i] = @stream.readUInt32()\n            \n        return\n        \n    # once we have all the information we need, generate the seek table for this track\n    setupSeekPoints: ->\n        return unless @track.chunkOffsets? and @track.stsc? and @track.sampleSize? and @track.stts?\n        \n        stscIndex = 0\n        sttsIndex = 0\n        sttsIndex = 0\n        sttsSample = 0\n        sampleIndex = 0\n        \n        offset = 0\n        timestamp = 0\n        @track.seekPoints = []\n        \n        for position, i in @track.chunkOffsets\n            for j in [0...@track.stsc[stscIndex].count] by 1\n                # push the timestamp and both the physical position in the file\n                # and the offset without gaps from the start of the data\n                @track.seekPoints.push\n                    offset: offset\n                    position: position\n                    timestamp: timestamp\n                \n                size = @track.sampleSize or @track.sampleSizes[sampleIndex++]\n                offset += size\n                position += size\n                timestamp += @track.stts[sttsIndex].duration\n                \n                if sttsIndex + 1 < @track.stts.length and ++sttsSample is @track.stts[sttsIndex].count\n                    sttsSample = 0\n                    sttsIndex++\n                    \n            if stscIndex + 1 < @track.stsc.length and i + 1 is @track.stsc[stscIndex + 1].first\n                stscIndex++\n        \n    after 'moov', ->        \n        # if the mdat block was at the beginning rather than the end, jump back to it\n        if @mdatOffset?\n            @stream.seek @mdatOffset - 8\n            \n        # choose a track\n        for track in @tracks when track.type is 'soun'\n            @track = track\n            break\n            \n        if @track.type isnt 'soun'\n            @track = null\n            return @emit 'error', 'No audio tracks in m4a file.'\n            \n        # emit info\n        @emit 'format', @track.format\n        @emit 'duration', @track.duration / @track.timeScale * 1000 | 0\n        if @track.cookie\n            @emit 'cookie', @track.cookie\n        \n        # use the seek points from the selected track\n        @seekPoints = @track.seekPoints\n        \n    atom 'mdat', ->\n        if not @startedData\n            @mdatOffset ?= @stream.offset\n            \n            # if we haven't read the headers yet, the mdat atom was at the beginning\n            # rather than the end. Skip over it for now to read the headers first, and\n            # come back later.\n            if @tracks.length is 0\n                bytes = Math.min(@stream.remainingBytes(), @len)\n                @stream.advance bytes\n                @len -= bytes\n                return\n            \n            @chunkIndex = 0\n            @stscIndex = 0\n            @sampleIndex = 0\n            @tailOffset = 0\n            @tailSamples = 0\n            \n            @startedData = true\n            \n        # read the chapter information if any\n        unless @readChapters\n            @readChapters = @parseChapters()\n            return if @break = not @readChapters\n            @stream.seek @mdatOffset\n            \n        # get the starting offset\n        offset = @track.chunkOffsets[@chunkIndex] + @tailOffset\n        length = 0\n        \n        # make sure we have enough data to get to the offset\n        unless @stream.available(offset - @stream.offset)\n            @break = true\n            return\n        \n        # seek to the offset\n        @stream.seek(offset)\n        \n        # calculate the maximum length we can read at once\n        while @chunkIndex < @track.chunkOffsets.length\n            # calculate the size in bytes of the chunk using the sample size table\n            numSamples = @track.stsc[@stscIndex].count - @tailSamples\n            chunkSize = 0\n            for sample in [0...numSamples] by 1\n                size = @track.sampleSize or @track.sampleSizes[@sampleIndex]\n                \n                # if we don't have enough data to add this sample, jump out\n                break unless @stream.available(length + size)\n                \n                length += size\n                chunkSize += size\n                @sampleIndex++\n            \n            # if we didn't make it through the whole chunk, add what we did use to the tail\n            if sample < numSamples\n                @tailOffset += chunkSize\n                @tailSamples += sample\n                break\n            else\n                # otherwise, we can move to the next chunk\n                @chunkIndex++\n                @tailOffset = 0\n                @tailSamples = 0\n                \n                # if we've made it to the end of a list of subsequent chunks with the same number of samples,\n                # go to the next sample to chunk entry\n                if @stscIndex + 1 < @track.stsc.length and @chunkIndex + 1 is @track.stsc[@stscIndex + 1].first\n                    @stscIndex++\n                \n                # if the next chunk isn't right after this one, jump out\n                if offset + length isnt @track.chunkOffsets[@chunkIndex]\n                    break\n        \n        # emit some data if we have any, otherwise wait for more\n        if length > 0\n            @emit 'data', @stream.readBuffer(length)\n            @break = @chunkIndex is @track.chunkOffsets.length\n        else\n            @break = true\n            \n    parseChapters: ->\n        return true unless @track.chapterTracks?.length > 0\n\n        # find the chapter track\n        id = @track.chapterTracks[0]\n        for track in @tracks\n            break if track.id is id\n\n        if track.id isnt id\n            @emit 'error', 'Chapter track does not exist.'\n\n        @chapters ?= []\n        \n        # use the seek table offsets to find chapter titles\n        while @chapters.length < track.seekPoints.length\n            point = track.seekPoints[@chapters.length]\n            \n            # make sure we have enough data\n            return false unless @stream.available(point.position - @stream.offset + 32)\n\n            # jump to the title offset\n            @stream.seek point.position\n\n            # read the length of the title string\n            len = @stream.readUInt16()\n            title = null\n            \n            return false unless @stream.available(len)\n            \n            # if there is a BOM marker, read a utf16 string\n            if len > 2\n                bom = @stream.peekUInt16()\n                if bom in [0xfeff, 0xfffe]\n                    title = @stream.readString(len, 'utf16-bom')\n\n            # otherwise, use utf8\n            title ?= @stream.readString(len, 'utf8')\n            \n            # add the chapter title, timestamp, and duration\n            nextTimestamp = track.seekPoints[@chapters.length + 1]?.timestamp ? track.duration\n            @chapters.push\n                title: title\n                timestamp: point.timestamp / track.timeScale * 1000 | 0\n                duration: (nextTimestamp - point.timestamp) / track.timeScale * 1000 | 0\n                \n        # we're done, so emit the chapter data\n        @emit 'chapters', @chapters\n        return true\n        \n    # metadata chunk\n    atom 'moov.udta.meta', ->\n        @metadata = {}        \n        @stream.advance(4) # version and flags\n        \n    # emit when we're done\n    after 'moov.udta.meta', ->\n        @emit 'metadata', @metadata\n\n    # convienience function to generate metadata atom handler\n    meta = (field, name, fn) ->\n        atom \"moov.udta.meta.ilst.#{field}.data\", ->\n            @stream.advance(8)\n            @len -= 8\n            fn.call this, name\n\n    # string field reader\n    string = (field) ->\n        @metadata[field] = @stream.readString(@len, 'utf8')\n\n    # from http://atomicparsley.sourceforge.net/mpeg-4files.html\n    meta '©alb', 'album', string\n    meta '©arg', 'arranger', string\n    meta '©art', 'artist', string\n    meta '©ART', 'artist', string\n    meta 'aART', 'albumArtist', string\n    meta 'catg', 'category', string\n    meta '©com', 'composer', string\n    meta '©cpy', 'copyright', string\n    meta 'cprt', 'copyright', string\n    meta '©cmt', 'comments', string\n    meta '©day', 'releaseDate', string\n    meta 'desc', 'description', string\n    meta '©gen', 'genre', string # custom genres\n    meta '©grp', 'grouping', string\n    meta '©isr', 'ISRC', string\n    meta 'keyw', 'keywords', string\n    meta '©lab', 'recordLabel', string\n    meta 'ldes', 'longDescription', string\n    meta '©lyr', 'lyrics', string\n    meta '©nam', 'title', string\n    meta '©phg', 'recordingCopyright', string\n    meta '©prd', 'producer', string\n    meta '©prf', 'performers', string\n    meta 'purd', 'purchaseDate', string\n    meta 'purl', 'podcastURL', string\n    meta '©swf', 'songwriter', string\n    meta '©too', 'encoder', string\n    meta '©wrt', 'composer', string\n\n    meta 'covr', 'coverArt', (field) ->\n        @metadata[field] = @stream.readBuffer(@len)\n\n    # standard genres\n    genres = [\n        \"Blues\", \"Classic Rock\", \"Country\", \"Dance\", \"Disco\", \"Funk\", \"Grunge\", \n        \"Hip-Hop\", \"Jazz\", \"Metal\", \"New Age\", \"Oldies\", \"Other\", \"Pop\", \"R&B\",\n        \"Rap\", \"Reggae\", \"Rock\", \"Techno\", \"Industrial\", \"Alternative\", \"Ska\", \n        \"Death Metal\", \"Pranks\", \"Soundtrack\", \"Euro-Techno\", \"Ambient\", \n        \"Trip-Hop\", \"Vocal\", \"Jazz+Funk\", \"Fusion\", \"Trance\", \"Classical\", \n        \"Instrumental\", \"Acid\", \"House\", \"Game\", \"Sound Clip\", \"Gospel\", \"Noise\",\n        \"AlternRock\", \"Bass\", \"Soul\", \"Punk\", \"Space\", \"Meditative\", \"Instrumental Pop\", \n        \"Instrumental Rock\", \"Ethnic\", \"Gothic\",  \"Darkwave\", \"Techno-Industrial\", \n        \"Electronic\", \"Pop-Folk\", \"Eurodance\", \"Dream\", \"Southern Rock\", \"Comedy\", \n        \"Cult\", \"Gangsta\", \"Top 40\", \"Christian Rap\", \"Pop/Funk\", \"Jungle\", \n        \"Native American\", \"Cabaret\", \"New Wave\", \"Psychadelic\", \"Rave\", \"Showtunes\",\n        \"Trailer\", \"Lo-Fi\", \"Tribal\", \"Acid Punk\", \"Acid Jazz\", \"Polka\", \"Retro\", \n        \"Musical\", \"Rock & Roll\", \"Hard Rock\", \"Folk\", \"Folk/Rock\", \"National Folk\", \n        \"Swing\", \"Fast Fusion\", \"Bebob\", \"Latin\", \"Revival\", \"Celtic\", \"Bluegrass\",\n        \"Avantgarde\", \"Gothic Rock\", \"Progressive Rock\", \"Psychedelic Rock\", \"Symphonic Rock\",\n        \"Slow Rock\", \"Big Band\", \"Chorus\", \"Easy Listening\", \"Acoustic\", \"Humour\", \"Speech\", \n        \"Chanson\", \"Opera\", \"Chamber Music\", \"Sonata\", \"Symphony\", \"Booty Bass\", \"Primus\", \n        \"Porn Groove\", \"Satire\", \"Slow Jam\", \"Club\", \"Tango\", \"Samba\", \"Folklore\", \"Ballad\", \n        \"Power Ballad\", \"Rhythmic Soul\", \"Freestyle\", \"Duet\", \"Punk Rock\", \"Drum Solo\", \n        \"A Capella\", \"Euro-House\", \"Dance Hall\"\n    ]\n\n    meta 'gnre', 'genre', (field) ->\n        @metadata[field] = genres[@stream.readUInt16() - 1]\n\n    meta 'tmpo', 'tempo', (field) ->\n        @metadata[field] = @stream.readUInt16()\n\n    meta 'rtng', 'rating', (field) ->\n        rating = @stream.readUInt8()\n        @metadata[field] = if rating is 2 then 'Clean' else if rating isnt 0 then 'Explicit' else 'None'\n\n    diskTrack = (field) ->\n        @stream.advance(2)\n        @metadata[field] = @stream.readUInt16() + ' of ' + @stream.readUInt16()\n        @stream.advance(@len - 6)\n\n    meta 'disk', 'diskNumber', diskTrack\n    meta 'trkn', 'trackNumber', diskTrack\n\n    bool = (field) ->\n        @metadata[field] = @stream.readUInt8() is 1\n\n    meta 'cpil', 'compilation', bool\n    meta 'pcst', 'podcast', bool\n    meta 'pgap', 'gapless', bool\n    \nmodule.exports = M4ADemuxer\n"]}},"error":null,"hash":"b2b5e12499513b9f280b5863b583ce00","cacheData":{"env":{}}}