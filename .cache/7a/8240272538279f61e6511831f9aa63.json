{"id":"node_modules/av/src/decoders/xlaw.coffee","dependencies":[{"name":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\package.json","includedInParent":true,"mtime":1624288368876},{"name":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\node_modules\\av\\package.json","includedInParent":true,"mtime":1624288427802},{"name":"../decoder","loc":{"line":5,"column":20},"parent":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\node_modules\\av\\src\\decoders\\xlaw.coffee","resolved":"C:\\Users\\Diego\\Downloads\\Documents\\three js\\AbsurbPlace\\node_modules\\av\\src\\decoder.coffee"}],"generated":{"js":"(function() {\n  var Decoder, XLAWDecoder,\n    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };\n\n  Decoder = require('../decoder');\n\n  XLAWDecoder = (function() {\n    var BIAS, QUANT_MASK, SEG_MASK, SEG_SHIFT, SIGN_BIT;\n\n    class XLAWDecoder extends Decoder {\n      constructor() {\n        super(...arguments);\n        this.readChunk = this.readChunk.bind(this);\n      }\n\n      init() {\n        var i, j, k, seg, t, table, val;\n        this.format.bitsPerChannel = 16;\n        this.table = table = new Int16Array(256);\n        if (this.format.formatID === 'ulaw') {\n          for (i = j = 0; j < 256; i = ++j) {\n            // Complement to obtain normal u-law value.\n            val = ~i;\n            \n            // Extract and bias the quantization bits. Then\n            // shift up by the segment number and subtract out the bias.\n            t = ((val & QUANT_MASK) << 3) + BIAS;\n            t <<= (val & SEG_MASK) >>> SEG_SHIFT;\n            table[i] = val & SIGN_BIT ? BIAS - t : t - BIAS;\n          }\n        } else {\n          for (i = k = 0; k < 256; i = ++k) {\n            val = i ^ 0x55;\n            t = val & QUANT_MASK;\n            seg = (val & SEG_MASK) >>> SEG_SHIFT;\n            if (seg) {\n              t = (t + t + 1 + 32) << (seg + 2);\n            } else {\n              t = (t + t + 1) << 3;\n            }\n            table[i] = val & SIGN_BIT ? t : -t;\n          }\n        }\n      }\n\n      readChunk() {\n        var i, j, output, ref, samples, stream, table;\n        boundMethodCheck(this, XLAWDecoder);\n        ({stream, table} = this);\n        samples = Math.min(4096, this.stream.remainingBytes());\n        if (samples === 0) {\n          return;\n        }\n        output = new Int16Array(samples);\n        for (i = j = 0, ref = samples; j < ref; i = j += 1) {\n          output[i] = table[stream.readUInt8()];\n        }\n        return output;\n      }\n\n    };\n\n    Decoder.register('ulaw', XLAWDecoder);\n\n    Decoder.register('alaw', XLAWDecoder);\n\n    SIGN_BIT = 0x80;\n\n    QUANT_MASK = 0xf;\n\n    SEG_SHIFT = 4;\n\n    SEG_MASK = 0x70;\n\n    BIAS = 0x84;\n\n    return XLAWDecoder;\n\n  }).call(this);\n\n}).call(this);\n"},"sourceMaps":{"js":{"version":3,"file":"","sourceRoot":"","sources":["node_modules/av/src/decoders/xlaw.coffee"],"names":[],"mappings":"AAAA;AAAA,MAAA,OAAA,EAAA,WAAA;IAAA;;EAAA,OAAA,GAAU,OAAA,CAAQ,YAAR;;EAEJ;;;IAAN,MAAA,YAAA,QAA0B,QAA1B;;;YAyCI,CAAA,gBAAA,CAAA;;;MA/BA,IAAM,CAAA,CAAA;AACV,YAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA,CAAA,EAAA,KAAA,EAAA;QAAQ,IAAC,CAAA,MAAM,CAAC,cAAR,GAAyB;QACzB,IAAC,CAAA,KAAD,GAAS,KAAA,GAAQ,IAAI,UAAJ,CAAe,GAAf;QAEjB,IAAG,IAAC,CAAA,MAAM,CAAC,QAAR,KAAoB,MAAvB;UACI,KAAS,2BAAT,GAAA;;YAEI,GAAA,GAAM,CAAC,EADvB;;;;YAKgB,CAAA,GAAI,CAAC,CAAC,GAAA,GAAM,UAAP,CAAA,IAAsB,CAAvB,CAAA,GAA4B;YAChC,CAAA,KAAM,CAAC,GAAA,GAAM,QAAP,CAAA,KAAqB;YAE3B,KAAK,CAAC,CAAD,CAAL,GAAc,GAAA,GAAM,QAAT,GAAuB,IAAA,GAAO,CAA9B,GAAqC,CAAA,GAAI;UATxD,CADJ;SAAA,MAAA;UAaI,KAAS,2BAAT;YACI,GAAA,GAAM,CAAA,GAAI;YACV,CAAA,GAAI,GAAA,GAAM;YACV,GAAA,GAAM,CAAC,GAAA,GAAM,QAAP,CAAA,KAAqB;YAE3B,IAAG,GAAH;cACI,CAAA,GAAI,CAAC,CAAA,GAAI,CAAJ,GAAQ,CAAR,GAAY,EAAb,CAAA,IAAoB,CAAC,GAAA,GAAM,CAAP,EAD5B;aAAA,MAAA;cAGI,CAAA,GAAI,CAAC,CAAA,GAAI,CAAJ,GAAQ,CAAT,CAAA,IAAe,EAHvB;;YAKA,KAAK,CAAC,CAAD,CAAL,GAAc,GAAA,GAAM,QAAT,GAAuB,CAAvB,GAA8B,CAAC;UAV9C,CAbJ;;MAJE;;MA+BN,SAAW,CAAA,CAAA;AACf,YAAA,CAAA,EAAA,CAAA,EAAA,MAAA,EAAA,GAAA,EAAA,OAAA,EAAA,MAAA,EAAA;+BA1CM;QA0CE,CAAA,CAAC,MAAD,EAAS,KAAT,CAAA,GAAkB,IAAlB;QAEA,OAAA,GAAU,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,IAAC,CAAA,MAAM,CAAC,cAAR,CAAA,CAAf;QACV,IAAU,OAAA,KAAW,CAArB;AAAA,iBAAA;;QAEA,MAAA,GAAS,IAAI,UAAJ,CAAe,OAAf;QACT,KAAS,6CAAT;UACI,MAAM,CAAC,CAAD,CAAN,GAAY,KAAK,CAAC,MAAM,CAAC,SAAP,CAAA,CAAD;QADrB;AAGA,eAAO;MAVA;;IAzCf;;IACI,OAAO,CAAC,QAAR,CAAiB,MAAjB,EAAyB,WAAzB;;IACA,OAAO,CAAC,QAAR,CAAiB,MAAjB,EAAyB,WAAzB;;IAEA,QAAA,GAAa;;IACb,UAAA,GAAa;;IACb,SAAA,GAAa;;IACb,QAAA,GAAa;;IACb,IAAA,GAAa;;;;;AAVjB","sourcesContent":["Decoder = require '../decoder'\n\nclass XLAWDecoder extends Decoder\n    Decoder.register('ulaw', XLAWDecoder)\n    Decoder.register('alaw', XLAWDecoder)\n    \n    SIGN_BIT   = 0x80\n    QUANT_MASK = 0xf\n    SEG_SHIFT  = 4\n    SEG_MASK   = 0x70\n    BIAS       = 0x84\n    \n    init: ->\n        @format.bitsPerChannel = 16\n        @table = table = new Int16Array(256)\n        \n        if @format.formatID is 'ulaw'\n            for i in [0...256]\n                # Complement to obtain normal u-law value.\n                val = ~i\n            \n                # Extract and bias the quantization bits. Then\n                # shift up by the segment number and subtract out the bias.\n                t = ((val & QUANT_MASK) << 3) + BIAS\n                t <<= (val & SEG_MASK) >>> SEG_SHIFT\n            \n                table[i] = if val & SIGN_BIT then BIAS - t else t - BIAS\n                                \n        else\n            for i in [0...256]\n                val = i ^ 0x55\n                t = val & QUANT_MASK\n                seg = (val & SEG_MASK) >>> SEG_SHIFT\n                \n                if seg\n                    t = (t + t + 1 + 32) << (seg + 2)\n                else\n                    t = (t + t + 1) << 3\n                    \n                table[i] = if val & SIGN_BIT then t else -t\n                \n        return\n            \n    readChunk: =>\n        {stream, table} = this\n        \n        samples = Math.min(4096, @stream.remainingBytes())\n        return if samples is 0\n        \n        output = new Int16Array(samples)\n        for i in [0...samples] by 1\n            output[i] = table[stream.readUInt8()]\n            \n        return output"]}},"error":null,"hash":"19e71abdf5ffe94f4554445233b3c1ad","cacheData":{"env":{}}}